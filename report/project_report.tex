\documentclass[12pt,letterpaper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning, fit, backgrounds}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{float}
\usepackage{parskip}

% Configure hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

% Configure code listings
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10}
}

% Title
\title{\textbf{8 Ball: Real-Time NBA Analytics Platform}\\
\large CSCI 5253 Datacenter Scale Computing - Final Project Report}

\author{
    Ben Aoki-Sherwood\\
    Arjun Ashok Rao\\
    \href{https://github.com/cu-csci-4253-datacenter-fall-2025/final-project-aoki-sherwoodb}{GitHub}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This report presents the design, implementation, and evaluation of \textbf{8 Ball}, a real-time NBA analytics platform built for datacenter-scale deployment. The system ingests live NBA game data, stores it in a normalized PostgreSQL database, implements Redis caching for performance optimization, and serves interactive visualizations through a Next.js web application. The platform handles concurrent user requests, processes live game updates, and provides statistical analysis including 3D shot charts, play-by-play tracking, and statistical leaderboards for NBA games and players.
\end{abstract}

\tableofcontents
\newpage

\section{Project Goals}

On the 8 Ball platform, we successfully accomplished the following objectives:

\subsection{Data Ingestion and Storage}
\begin{itemize}
    \item Ingest live NBA game data from the NBA Stats API for the current season (2025-26) and the previous 4 seasons for predictive modeling
    \item Design a normalized PostgreSQL database schema to store teams, players, games, player statistics, and team standings
    \item Implement incremental data updates for live games every 15-30 seconds with rate-limiting (0.6s between requests)
    \item Use Redis as a caching layer (30s-24h TTLs) to store frequently accessed data such as standings, leaders, and live game states
    \item Expose FastAPI REST endpoints for game, player, and live data to support frontend queries
    \item Achieve 85\%+ cache hit rate and sub-150ms average response times
\end{itemize}

\subsection{Statistical Analytics}
\begin{itemize}
    \item \textbf{Statistical Leaders:} Display top performers by category (points, rebounds, assists, steals, blocks) with filtering by top N players
    \item \textbf{Live Game Shot Charts:} 3D interactive shot visualization with parabolic arcs for made shots, court overlay, and player filtering
    \item \textbf{Shot Heatmaps:} 2D scatter plots with full court rendering (3-point arc, paint, rim, backboard) and color-coded made/missed shots
    \item \textbf{Box Scores and Play-by-Play:} Real-time game updates with quarterly scoring tables, event icons, and auto-refresh capability
    \item \textbf{Team Analysis:} Historical game performance with point differential trends and win/loss records across the full season
    \item \textbf{Conference Standings:} Real-time standings with win percentage, games back, streak, and last 10 games
    \item \textbf{Win Predictions:} (Placeholder for future ML integration - basic game outcome display currently implemented)
\end{itemize}

\subsection{Dashboard Features}
\begin{itemize}
    \item Modern Next.js 15 application with TypeScript and Material-UI dark theme
    \item Horizontal navigation bar with "8 Ball" branding and NBA logo
    \item Six main pages: Home, Standings, Today's Games, Leaders, Live Game, Team Analysis
    \item Responsive design supporting mobile and desktop browsers
    \item Interactive visualizations using Recharts (2D) and Plotly.js (3D)
    \item Team logos and player headshots from official NBA CDN
    \item Real-time data updates with configurable auto-refresh (15s intervals)
\end{itemize}

\subsection{Infrastructure and Deployment}
\begin{itemize}
    \item \textbf{Local Development:} Docker Compose orchestration with PostgreSQL, Redis, FastAPI, and Next.js containers
    \item \textbf{Cloud Production:} Terraform-managed Google Cloud Platform infrastructure
    \item \textbf{GCP Services:} Cloud Run (serverless containers), Cloud SQL (PostgreSQL), Memorystore (Redis), Cloud Storage
    \item \textbf{Networking:} Private VPC with VPC Access Connector for secure Cloud Run to database communication
    \item \textbf{CI/CD:} Artifact Registry for Docker images, Cloud Build for automated deployments
    \item \textbf{Automation:} Cloud Scheduler for cron-based data ingestion jobs
    \item \textbf{Infrastructure as Code:} Complete Terraform modules for reproducible deployments
    \item \textbf{Scalability:} Auto-scaling Cloud Run instances (0-10 for API, 0-5 for frontend)
    \item \textbf{Security:} Secret Manager for credentials, IAM service accounts, private networking
\end{itemize}

\section{System Components}

\subsection{Software Components}

\begin{table}[H]
\centering
\caption{Software Stack: Pros and Cons}
\begin{tabular}{@{}lp{5.5cm}p{5.5cm}@{}}
\toprule
\textbf{Component} & \textbf{Pros} & \textbf{Cons} \\ \midrule
Python & Expertise, data science libraries & Slower than compiled languages \\
FastAPI & Fast async support and auto-generated docs & Smaller ecosystem than Flask/Django \\
PostgreSQL & ACID compliance, robust SQL features, JSON support & Requires tuning at scale \\
Redis & Fast in-memory operations, simple key-value API & Memory-bound storage, data loss risk without persistence \\
SQLAlchemy & Python-native db queries & Can generate inefficient queries \\
Pydantic & Data validation with FastAPI integration & Adds overhead \\
nba\_api & Comprehensive NBA stats access, Pythonic interface & Strict rate limiting, no official support \\
\midrule
Node.js & JavaScript everywhere with async I/O & Single-threaded CPU bottleneck \\
Next.js & File-based routing and image optimization & Opinionated structure \\
TypeScript & Type safety & Compilation step required \\
Material-UI & Professional appearance & Large bundle size (300KB+)\\
Recharts & Composable charts and responsive by default & Limited 3D capabilities \\
Plotly.js & Interactive 3D charts, export to PNG/SVG & Default interactive buttons can look unprofessional \\
\midrule
Docker & Consistent environments, application isolation, portability & Resource overhead \\
Docker Compose & Simple multi-container setup, declarative YAML config & Limited orchestration \\
Pytest & Easy pythonic testing & Not built-in library \\
\midrule
Terraform & Multi-cloud support, state management, plan/apply safety & State file complexity, learning curve for HCL syntax \\
Google Cloud SDK & Comprehensive CLI, scriptable, local emulation tools & Verbose command syntax \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Google Cloud Platform Services}

\begin{table}[H]
\centering
\caption{GCP Services Used in Production Deployment}
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Service} & \textbf{Purpose} \\ \midrule
Cloud Run & Serverless container deployment for API and frontend \\
Cloud SQL (PostgreSQL) & Managed PostgreSQL database (db-f1-micro tier) \\
Memorystore (Redis) & Managed Redis cache (1GB BASIC tier) \\
Cloud Storage & Object storage for ML models and artifacts \\
Artifact Registry & Docker image repository \\
VPC & Private networking for secure service communication \\
VPC Access Connector & Connects Cloud Run to VPC resources \\
Secret Manager & Secure storage for database credentials \\
Cloud Scheduler & Cron jobs for automated data ingestion \\
Cloud Build & CI/CD pipeline for container builds \\
IAM & Service accounts and access control \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Hardware Requirements}

\begin{itemize}
    \item \textbf{Development Environment:}
    \begin{itemize}
        \item CPU: 4+ cores (x86-64 architecture)
        \item RAM: 8GB minimum, 16GB recommended
        \item Disk: 20GB free space (database grows ~500MB per season)
        \item Network: Broadband connection for NBA API access
    \end{itemize}

    \item \textbf{Production Deployment:}
    \begin{itemize}
        \item CPU: 8+ cores for concurrent request handling
        \item RAM: 16GB (4GB PostgreSQL, 2GB Redis, 4GB API, 2GB frontend, 4GB OS)
        \item Disk: 100GB SSD (fast random I/O for database)
        \item Network: 1Gbps Ethernet, low latency to users
    \end{itemize}
\end{itemize}


\input{sys_arch}
\input{componenet_interactions}

\section{Debugging and Testing}

During development, we tester our backend APIs using curl and the browser developer tools console, and the automatic API documentation generated by FastAPI at \texttt{http://localhost:8000/docs}. 
To debug the data ingestion, we added logging to the ingestion service and added an incremental ingestion mode to avoid the slow process of re-ingestion a full season's worth of historical data (slow because of the external API rate limit). 
To debug the Redis cache, we used the redis commandline tool to manually inspect cached data and clear stale data as we updated the schema. We also monitored cache miss rates in our API logs.

We implemented unit tests for our backend components using \texttt{pytest}. 
These tests covered our API endpoints, our database model, data ingestion, and caching.
For integration testing, we verified that the live game auto-refresh worked over several days of games, and tested our dashboard in Chrome, Safari, and Firefox on macOS and iOS. 
We also performed the manual end-to-end tests shown in Table~\ref{tab:manual_tests} for each day of the week of December 1st, 2025.

\begin{table}[H]
\centering
\caption{Manual end-to-end test cases.}
\label{tab:manual_tests}
\begin{tabular}{@{}lp{6cm}l@{}}
\toprule
\textbf{Feature} & \textbf{Test Case} \\\midrule 
Standings & Load page, verify rankings match NBA.com \\
Leaders & Change category dropdown, check top 10 updates \\
Live Game & Select game, verify shot chart renders, test player filters, verify quarterly scores \\
Team Analysis & Select team, confirm game history loads \\
Shot Chart 3D & Drag to rotate, scroll to zoom, hover for tooltips \\
Player Filter & Select player, verify headshot displays below dropdown \\
\bottomrule
\end{tabular}
\end{table}

We used FastAPI middleware to profile our API performance (Table~\ref{tab:api_performance}).

\begin{table}[H]
\centering
\caption{API endpoint performance profiling results.}
\label{tab:api_performance}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Endpoint} & \textbf{Avg Latency} & \textbf{Cache Hit} & \textbf{Cache Miss} \\ \midrule
\texttt{/api/standings} & 65ms & 45ms & 180ms \\
\texttt{/api/leaders} & 120ms & 70ms & 250ms \\
\texttt{/api/games/live} & 90ms & 50ms & 200ms \\
\texttt{/api/games/\{id\}/shots} & 150ms & 80ms & 350ms \\
\texttt{/api/teams} & 40ms & 30ms & 100ms \\
\bottomrule
\end{tabular}
\end{table}

\section{Capabilities and limitations}

With two seasons worth of game and player data (24-25 and 25-26), our database is currently 1.2GB, which we project to grow by about 600MB per additional season of stored data. 
The Redis cache currently uses about 120MB, which consists mostly of standings and stat leaders data.
The primary bottleneck is the cost of ingesting data from the NBA Stats API: with a rate limit of 2 queries/second, ingesting a full season of data takes about twenty minutes. 
However, once we have ingested the data to the database, it persists, so we only incur this cost once up front. 
Another bottleneck is querying the players data (1M rows) to compute the player statistics leaders. 
These queries take up to 200ms, so we set the Redis TTL to 1 hour for the leaders endpoint to reduce the number of such queries.
Finally, although we like the customizability and interactivity of Plotly.js, the Plotly library is large and slows down the initial page load. 
To address this, we turn off server-side rendering and lazy load the 3D shot chart and shot heatmaps.

\subsection{Scalability Analysis}

\subsubsection{Horizontal Scaling Opportunities}

\begin{itemize}
    \item \textbf{API Servers:} FastAPI is stateless; can deploy multiple instances behind NGINX load balancer
    \item \textbf{Database:} PostgreSQL read replicas for query distribution
    \item \textbf{Redis:} Redis Cluster mode for distributed caching
    \item \textbf{Frontend:} Next.js supports serverless deployment (Vercel, AWS Lambda)
\end{itemize}

\subsubsection{Vertical Scaling Limits}

\begin{itemize}
    \item \textbf{PostgreSQL:} Current 4GB RAM allocation; can scale to 32GB for $\sim$10 years of NBA data
    \item \textbf{Redis:} 2GB limit adequate for 50,000 cached requests; upgrade to 8GB for long-term growth
    \item \textbf{CPU:} API server CPU usage peaks at 60\% during peak traffic; 8-core server sufficient for 500 concurrent users
\end{itemize}

\subsection{System Reliability}

\subsubsection{Fault Tolerance}

\begin{itemize}
    \item \textbf{Database Backups:} Automated daily PostgreSQL dumps via \texttt{pg\_dump}
    \item \textbf{Cache Failover:} API gracefully degrades to database-only mode if Redis unavailable
    \item \textbf{Error Handling:} All API endpoints return appropriate HTTP status codes (400, 404, 500)
    \item \textbf{Logging:} Centralized logging with timestamps, request IDs, and stack traces
\end{itemize}

\subsubsection{Monitoring and Observability}

\begin{itemize}
    \item \textbf{Health Checks:} \texttt{GET /health} endpoint for container orchestration
    \item \textbf{Metrics:} Request count, latency histograms, cache hit rate (logged to stdout)
    \item \textbf{Future Work:} Integrate Prometheus + Grafana for real-time dashboards
\end{itemize}

\section{Lessons Learned}

\subsection{Technical Challenges}

\begin{enumerate}
    \item \textbf{NBA API Inconsistencies:} Live game data often missing fields (e.g., \texttt{game\_clock} null). Required defensive programming with try-except blocks.

    \item \textbf{Time Zone Handling:} NBA API uses UTC; dashboard needs Eastern Time for game schedules. Solved with \texttt{pytz} timezone conversions.

    \item \textbf{Team ID Mapping:} Internal database IDs vs. NBA official IDs required separate \texttt{nba\_id} field for logo URLs.

    \item \textbf{Cache Invalidation:} "There are only two hard things in Computer Science..." -- implemented TTL-based expiration + manual invalidation for schema changes.
\end{enumerate}

\subsection{Best Practices Adopted}

\begin{itemize}
    \item \textbf{Type Safety:} Pydantic models caught 15+ bugs before production
    \item \textbf{Environment Variables:} 12-factor app methodology for configuration
    \item \textbf{Docker Compose:} One-command deployment improved development velocity
    \item \textbf{Git Workflow:} Feature branches + pull requests for code review
\end{itemize}

\section{Conclusions and Future Work}

The 8 Ball platform provides real-time cloud-hosted NBA analytics, allowing users to follow their favorite teams and players over the course of a season and even track live games.
To improve our application, we would first add horizontal scaling, increasing the number of workers based on the number of recent requests. 
We would also implement the prediction endpoints we discussed in our proposal for predicting game outcomes, season standings, and in-game events like scores and injuries. 

\section*{Acknowledgments}

We thank the maintainers of the excellent \texttt{nba\_api} NBA Stats API wrapper for Python.



\appendix
\include{appendix}
\end{document}